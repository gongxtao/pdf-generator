# HTML100%还原Word页面效果

## 技术解决方案
```
// Word文档100%还原解析方案

// 方案1：深度解析Word XML结构 + 精确CSS映射
class WordToHtmlConverter {
  constructor() {
    this.pageSettings = {}
    this.styles = new Map()
    this.fonts = new Map()
    this.images = new Map()
  }

  async convertWithPerfectFidelity(docxBuffer) {
    // 1. 解压docx文件，获取所有XML文件
    const zip = await JSZip.loadAsync(docxBuffer)
    
    // 2. 解析关键文件
    const documentXml = await zip.file('word/document.xml').async('text')
    const stylesXml = await zip.file('word/styles.xml').async('text')
    const settingsXml = await zip.file('word/settings.xml').async('text')
    const fontTableXml = await zip.file('word/fontTable.xml').async('text')
    
    // 3. 解析页面设置（关键：确保页面尺寸一致）
    this.pageSettings = this.parsePageSettings(settingsXml, documentXml)
    
    // 4. 解析字体表（确保字体100%一致）
    this.fonts = this.parseFontTable(fontTableXml)
    
    // 5. 解析样式定义（Word的样式系统）
    this.styles = this.parseStyles(stylesXml)
    
    // 6. 解析文档内容，逐个元素精确转换
    const htmlContent = await this.parseDocumentContent(documentXml, zip)
    
    // 7. 生成精确的CSS
    const css = this.generatePreciseCSS()
    
    return {
      html: this.wrapWithPageContainer(htmlContent),
      css: css,
      fonts: Array.from(this.fonts.values()),
      images: Array.from(this.images.values())
    }
  }

  // 解析页面设置 - 确保页面尺寸完全一致
  parsePageSettings(settingsXml, documentXml) {
    const parser = new DOMParser()
    const settingsDoc = parser.parseFromString(settingsXml, 'text/xml')
    const docDoc = parser.parseFromString(documentXml, 'text/xml')
    
    // 从sectPr元素获取页面设置
    const sectPr = docDoc.querySelector('w\\:sectPr, sectPr')
    const pgSz = sectPr?.querySelector('w\\:pgSz, pgSz')
    const pgMar = sectPr?.querySelector('w\\:pgMar, pgMar')
    
    return {
      // Word页面尺寸（以磅为单位）
      pageWidth: this.twipsToPoints(pgSz?.getAttribute('w:w') || pgSz?.getAttribute('w') || 11906), // A4默认宽度
      pageHeight: this.twipsToPoints(pgSz?.getAttribute('w:h') || pgSz?.getAttribute('h') || 16838), // A4默认高度
      
      // 页边距
      marginTop: this.twipsToPoints(pgMar?.getAttribute('w:top') || pgMar?.getAttribute('top') || 1440),
      marginRight: this.twipsToPoints(pgMar?.getAttribute('w:right') || pgMar?.getAttribute('right') || 1440),
      marginBottom: this.twipsToPoints(pgMar?.getAttribute('w:bottom') || pgMar?.getAttribute('bottom') || 1440),
      marginLeft: this.twipsToPoints(pgMar?.getAttribute('w:left') || pgMar?.getAttribute('left') || 1440),
      
      // 页面方向
      orientation: pgSz?.getAttribute('w:orient') || pgSz?.getAttribute('orient') || 'portrait'
    }
  }

  // 解析字体表 - 确保字体精确匹配
  parseFontTable(fontTableXml) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(fontTableXml, 'text/xml')
    const fonts = new Map()
    
    const fontElements = doc.querySelectorAll('w\\:font, font')
    fontElements.forEach(font => {
      const name = font.getAttribute('w:name') || font.getAttribute('name')
      const charset = font.querySelector('w\\:charset, charset')?.getAttribute('w:val')
      const family = font.querySelector('w\\:family, family')?.getAttribute('w:val')
      const pitch = font.querySelector('w\\:pitch, pitch')?.getAttribute('w:val')
      
      fonts.set(name, {
        name: name,
        charset: charset,
        family: this.mapFontFamily(family),
        pitch: pitch,
        // 生成CSS font-family声明
        cssFamily: this.generateFontFamilyCSS(name, family)
      })
    })
    
    return fonts
  }

  // 解析样式定义 - Word样式系统映射
  parseStyles(stylesXml) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(stylesXml, 'text/xml')
    const styles = new Map()
    
    const styleElements = doc.querySelectorAll('w\\:style, style')
    styleElements.forEach(style => {
      const styleId = style.getAttribute('w:styleId') || style.getAttribute('styleId')
      const type = style.getAttribute('w:type') || style.getAttribute('type')
      const name = style.querySelector('w\\:name, name')?.getAttribute('w:val')
      
      // 解析字符格式属性
      const rPr = style.querySelector('w\\:rPr, rPr')
      // 解析段落格式属性  
      const pPr = style.querySelector('w\\:pPr, pPr')
      
      styles.set(styleId, {
        id: styleId,
        name: name,
        type: type,
        characterProps: this.parseCharacterProperties(rPr),
        paragraphProps: this.parseParagraphProperties(pPr)
      })
    })
    
    return styles
  }

  // 解析字符属性 - 精确映射到CSS
  parseCharacterProperties(rPr) {
    if (!rPr) return {}
    
    const props = {}
    
    // 字体
    const rFonts = rPr.querySelector('w\\:rFonts, rFonts')
    if (rFonts) {
      props.fontFamily = rFonts.getAttribute('w:ascii') || rFonts.getAttribute('ascii')
    }
    
    // 字号 (半点单位转换为点)
    const sz = rPr.querySelector('w\\:sz, sz')
    if (sz) {
      props.fontSize = (parseInt(sz.getAttribute('w:val') || sz.getAttribute('val')) / 2) + 'pt'
    }
    
    // 字体颜色
    const color = rPr.querySelector('w\\:color, color')
    if (color) {
      const colorVal = color.getAttribute('w:val') || color.getAttribute('val')
      if (colorVal && colorVal !== 'auto') {
        props.color = '#' + colorVal
      }
    }
    
    // 粗体
    const b = rPr.querySelector('w\\:b, b')
    if (b && (!b.hasAttribute('w:val') || b.getAttribute('w:val') !== '0')) {
      props.fontWeight = 'bold'
    }
    
    // 斜体
    const i = rPr.querySelector('w\\:i, i')
    if (i && (!i.hasAttribute('w:val') || i.getAttribute('w:val') !== '0')) {
      props.fontStyle = 'italic'
    }
    
    // 下划线
    const u = rPr.querySelector('w\\:u, u')
    if (u) {
      const uType = u.getAttribute('w:val') || u.getAttribute('val')
      if (uType && uType !== 'none') {
        props.textDecoration = 'underline'
      }
    }
    
    // 背景色
    const highlight = rPr.querySelector('w\\:highlight, highlight')
    if (highlight) {
      const highlightVal = highlight.getAttribute('w:val') || highlight.getAttribute('val')
      props.backgroundColor = this.mapHighlightColor(highlightVal)
    }
    
    return props
  }

  // 解析段落属性 - 精确映射布局
  parseParagraphProperties(pPr) {
    if (!pPr) return {}
    
    const props = {}
    
    // 对齐方式
    const jc = pPr.querySelector('w\\:jc, jc')
    if (jc) {
      const align = jc.getAttribute('w:val') || jc.getAttribute('val')
      props.textAlign = this.mapAlignment(align)
    }
    
    // 段落间距
    const spacing = pPr.querySelector('w\\:spacing, spacing')
    if (spacing) {
      const before = spacing.getAttribute('w:before') || spacing.getAttribute('before')
      const after = spacing.getAttribute('w:after') || spacing.getAttribute('after')
      const line = spacing.getAttribute('w:line') || spacing.getAttribute('line')
      const lineRule = spacing.getAttribute('w:lineRule') || spacing.getAttribute('lineRule')
      
      if (before) props.marginTop = this.twipsToPoints(before) + 'pt'
      if (after) props.marginBottom = this.twipsToPoints(after) + 'pt'
      
      // 行间距处理
      if (line && lineRule) {
        if (lineRule === 'auto') {
          props.lineHeight = (parseInt(line) / 240) // 240 = 12pt * 20 twips/pt
        } else {
          props.lineHeight = this.twipsToPoints(line) + 'pt'
        }
      }
    }
    
    // 缩进
    const ind = pPr.querySelector('w\\:ind, ind')
    if (ind) {
      const left = ind.getAttribute('w:left') || ind.getAttribute('left')
      const right = ind.getAttribute('w:right') || ind.getAttribute('right')
      const firstLine = ind.getAttribute('w:firstLine') || ind.getAttribute('firstLine')
      const hanging = ind.getAttribute('w:hanging') || ind.getAttribute('hanging')
      
      if (left) props.marginLeft = this.twipsToPoints(left) + 'pt'
      if (right) props.marginRight = this.twipsToPoints(right) + 'pt'
      if (firstLine) props.textIndent = this.twipsToPoints(firstLine) + 'pt'
      if (hanging) props.textIndent = '-' + this.twipsToPoints(hanging) + 'pt'
    }
    
    return props
  }

  // 解析文档内容 - 精确转换每个元素
  async parseDocumentContent(documentXml, zip) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(documentXml, 'text/xml')
    
    const body = doc.querySelector('w\\:body, body')
    let htmlContent = ''
    
    for (const element of body.children) {
      if (element.tagName.includes('p')) {
        htmlContent += await this.convertParagraph(element, zip)
      } else if (element.tagName.includes('tbl')) {
        htmlContent += await this.convertTable(element, zip)
      }
    }
    
    return htmlContent
  }

  // 转换段落 - 保持精确格式
  async convertParagraph(pElement, zip) {
    const pPr = pElement.querySelector('w\\:pPr, pPr')
    const runs = pElement.querySelectorAll('w\\:r, r')
    
    // 获取段落样式
    const paragraphStyle = this.getParagraphStyle(pPr)
    const paragraphClass = this.generateParagraphClass(paragraphStyle)
    
    let paragraphContent = ''
    
    // 处理每个文本运行(run)
    for (const run of runs) {
      const rPr = run.querySelector('w\\:rPr, rPr')
      const characterStyle = this.getCharacterStyle(rPr)
      const characterClass = this.generateCharacterClass(characterStyle)
      
      // 处理文本、图片、对象等
      const texts = run.querySelectorAll('w\\:t, t')
      const drawings = run.querySelectorAll('w\\:drawing, drawing')
      
      for (const text of texts) {
        const textContent = text.textContent
        paragraphContent += `<span class="${characterClass}">${this.escapeHtml(textContent)}</span>`
      }
      
      for (const drawing of drawings) {
        const imageHtml = await this.convertDrawing(drawing, zip)
        paragraphContent += imageHtml
      }
    }
    
    return `<p class="${paragraphClass}">${paragraphContent}</p>`
  }

  // 工具方法：单位转换
  twipsToPoints(twips) {
    return parseFloat(twips) / 20 // 1 point = 20 twips
  }
  
  pointsToPixels(points) {
    return parseFloat(points) * 1.333 // 1 point ≈ 1.333 pixels at 96 DPI
  }

  // 生成页面容器HTML
  wrapWithPageContainer(content) {
    const { pageWidth, pageHeight, marginTop, marginRight, marginBottom, marginLeft } = this.pageSettings
    
    return `
      <div class="word-document-container" style="
        width: ${pageWidth}pt;
        height: ${pageHeight}pt;
        padding: ${marginTop}pt ${marginRight}pt ${marginBottom}pt ${marginLeft}pt;
        margin: 0 auto;
        background: white;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        position: relative;
      ">
        ${content}
      </div>
    `
  }

  // 生成精确CSS
  generatePreciseCSS() {
    let css = `
      /* Word文档精确还原CSS */
      @page {
        size: ${this.pageSettings.pageWidth}pt ${this.pageSettings.pageHeight}pt;
        margin: 0;
      }
      
      .word-document-container {
        font-family: 'Times New Roman', serif;
        font-size: 12pt;
        line-height: 1;
        color: #000000;
        box-sizing: border-box;
      }
    `
    
    // 添加字体定义
    for (const font of this.fonts.values()) {
      if (font.customFont) {
        css += font.cssFamily
      }
    }
    
    // 添加生成的样式类
    css += this.getGeneratedStylesCSS()
    
    return css
  }
}

// 方案2：使用Office.js API + 渲染引擎
class OfficeJSConverter {
  async convertWithOfficeAPI(file) {
    // 这个方案需要Office环境，但能获得最准确的渲染信息
    return new Promise((resolve, reject) => {
      Office.onReady(() => {
        Office.context.document.getSelectedDataAsync(
          Office.CoercionType.Html,
          { valueFormat: Office.ValueFormat.Formatted },
          (result) => {
            if (result.status === Office.AsyncResultStatus.Succeeded) {
              resolve({
                html: result.value,
                // 需要额外获取样式信息
              })
            } else {
              reject(result.error)
            }
          }
        )
      })
    })
  }
}

// 方案3：混合方案 - mammoth.js增强 + 后处理
class EnhancedMammothConverter {
  async convertWithEnhancement(buffer) {
    // 1. 使用mammoth进行基础转换
    const mammothResult = await mammoth.convertToHtml({ buffer }, {
      styleMap: this.createComprehensiveStyleMap(),
      transformDocument: this.transformDocument.bind(this),
      convertImage: mammoth.images.imgElement((image) => {
        return this.processImage(image)
      })
    })
    
    // 2. 后处理：修正mammoth无法处理的样式
    const enhancedHtml = this.postProcessHtml(mammothResult.value)
    const extractedCSS = this.extractAndEnhanceStyles(enhancedHtml)
    
    return {
      html: enhancedHtml,
      css: extractedCSS,
      warnings: mammothResult.messages
    }
  }

  createComprehensiveStyleMap() {
    return [
      // 标题映射
      "p[style-name='Heading 1'] => h1:fresh",
      "p[style-name='Heading 2'] => h2:fresh", 
      "p[style-name='Heading 3'] => h3:fresh",
      
      // 字符样式映射  
      "r[style-name='Strong'] => strong",
      "r[style-name='Emphasis'] => em",
      
      // 段落样式映射
      "p[style-name='Quote'] => blockquote:fresh",
      
      // 表格样式映射
      "table => table.word-table:fresh",
      
      // 保留原始样式信息的映射
      "p => p:preserve-style-properties",
      "r => span:preserve-style-properties"
    ]
  }

  postProcessHtml(html) {
    // 使用DOM操作精确修正样式
    const parser = new DOMParser()
    const doc = parser.parseFromString(html, 'text/html')
    
    // 修正字体、间距、对齐等mammoth丢失的样式
    this.fixFontStyles(doc)
    this.fixSpacing(doc)
    this.fixAlignment(doc)
    this.fixTableStyles(doc)
    
    return doc.documentElement.outerHTML
  }
}

export { WordToHtmlConverter, EnhancedMammothConverter }
```

## 总结
选用方案：方案1 + 方案3混合，深度XML解析 + mammoth.js增强 + 后处理修正
核心要点：

- 直接解析Word的XML结构（document.xml, styles.xml等）
- 精确提取页面设置、字体、样式定义
- 使用twips→points→pixels的精确单位转换
- 后处理修正mammoth.js无法处理的复杂样式

---

# 提取HTML的CSS样式作为模板解决方案

## 技术解决方案
```
// CSS模板提取和生成系统

class CSSTemplateExtractor {
  constructor() {
    this.extractedStyles = new Map()
    this.stylePatterns = new Map()
    this.templateParameters = new Map()
  }

  // 主要方法：从HTML提取可复用的CSS模板
  async extractTemplate(htmlContent, originalWordStyles = null) {
    // 1. 解析HTML，分析所有元素的样式
    const styleAnalysis = this.analyzeElementStyles(htmlContent)
    
    // 2. 识别样式模式和重复规律
    const patterns = this.identifyStylePatterns(styleAnalysis)
    
    // 3. 提取可参数化的属性
    const parameters = this.extractParameterizable(patterns)
    
    // 4. 生成模板CSS
    const template = this.generateTemplate(patterns, parameters)
    
    // 5. 生成应用系统（模板+内容=新文档）
    const applicator = this.createTemplateApplicator(template)
    
    return {
      template: template,
      parameters: parameters,
      applicator: applicator,
      metadata: {
        extractedAt: new Date(),
        sourceElements: styleAnalysis.length,
        patterns: patterns.size,
        parameters: parameters.size
      }
    }
  }

  // 1. 分析HTML中所有元素的样式
  analyzeElementStyles(htmlContent) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(htmlContent, 'text/html')
    const analysis = []

    // 遍历所有有意义的元素
    const elements = doc.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, div, table, th, td, blockquote, ul, ol, li')
    
    elements.forEach((element, index) => {
      const computedStyle = this.getElementComputedStyle(element)
      const semanticInfo = this.getSemanticInfo(element)
      
      analysis.push({
        id: `element_${index}`,
        tagName: element.tagName.toLowerCase(),
        className: element.className,
        textContent: element.textContent.substring(0, 50), // 前50字符用于模式识别
        styles: computedStyle,
        semantic: semanticInfo,
        hierarchy: this.getElementHierarchy(element),
        position: this.getElementPosition(element)
      })
    })

    return analysis
  }

  // 获取元素的计算样式（关键样式属性）
  getElementComputedStyle(element) {
    const style = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle
    
    return {
      // 字体相关
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle,
      color: style.color,
      
      // 间距相关
      marginTop: style.marginTop,
      marginRight: style.marginRight, 
      marginBottom: style.marginBottom,
      marginLeft: style.marginLeft,
      paddingTop: style.paddingTop,
      paddingRight: style.paddingRight,
      paddingBottom: style.paddingBottom,
      paddingLeft: style.paddingLeft,
      
      // 布局相关
      textAlign: style.textAlign,
      lineHeight: style.lineHeight,
      textIndent: style.textIndent,
      
      // 背景和边框
      backgroundColor: style.backgroundColor,
      borderTop: style.borderTop,
      borderRight: style.borderRight,
      borderBottom: style.borderBottom,
      borderLeft: style.borderLeft,
      borderRadius: style.borderRadius,
      
      // 显示和定位
      display: style.display,
      position: style.position,
      width: style.width,
      height: style.height
    }
  }

  // 获取语义信息
  getSemanticInfo(element) {
    return {
      isHeading: /^h[1-6]$/i.test(element.tagName),
      headingLevel: element.tagName.match(/^h([1-6])$/i)?.[1] || null,
      isParagraph: element.tagName.toLowerCase() === 'p',
      isTable: ['table', 'th', 'td'].includes(element.tagName.toLowerCase()),
      isList: ['ul', 'ol', 'li'].includes(element.tagName.toLowerCase()),
      isEmphasis: ['strong', 'em', 'b', 'i'].includes(element.tagName.toLowerCase()),
      hasContent: element.textContent.trim().length > 0
    }
  }

  // 2. 识别样式模式
  identifyStylePatterns(styleAnalysis) {
    const patterns = new Map()

    // 按语义类型分组
    const groupedByType = this.groupBySemanticType(styleAnalysis)
    
    // 为每种类型识别模式
    for (const [type, elements] of groupedByType) {
      const typePatterns = this.identifyTypePatterns(type, elements)
      patterns.set(type, typePatterns)
    }

    return patterns
  }

  // 按语义类型分组
  groupBySemanticType(analysis) {
    const groups = new Map()
    
    analysis.forEach(element => {
      let type = 'paragraph' // 默认类型
      
      if (element.semantic.isHeading) {
        type = `heading-${element.semantic.headingLevel}`
      } else if (element.semantic.isTable) {
        type = `table-${element.tagName}`
      } else if (element.semantic.isList) {
        type = `list-${element.tagName}`
      } else if (element.tagName === 'blockquote') {
        type = 'blockquote'
      }
      
      if (!groups.has(type)) {
        groups.set(type, [])
      }
      groups.get(type).push(element)
    })

    return groups
  }

  // 识别特定类型的样式模式
  identifyTypePatterns(type, elements) {
    if (elements.length === 0) return {}

    // 统计各样式属性的分布
    const styleFrequency = {}
    const styleVariations = {}

    // 关键样式属性
    const keyProperties = [
      'fontFamily', 'fontSize', 'fontWeight', 'color',
      'marginTop', 'marginBottom', 'textAlign', 'lineHeight'
    ]

    keyProperties.forEach(prop => {
      styleFrequency[prop] = {}
      styleVariations[prop] = new Set()
      
      elements.forEach(element => {
        const value = element.styles[prop]
        if (value && value !== 'auto' && value !== 'normal') {
          styleFrequency[prop][value] = (styleFrequency[prop][value] || 0) + 1
          styleVariations[prop].add(value)
        }
      })
    })

    // 识别主导样式（出现频率最高的）
    const dominantStyles = {}
    const variableStyles = {}

    keyProperties.forEach(prop => {
      const frequencies = styleFrequency[prop]
      const variations = styleVariations[prop]
      
      if (variations.size === 1) {
        // 只有一种值，设为固定样式
        dominantStyles[prop] = Array.from(variations)[0]
      } else if (variations.size <= 3) {
        // 少量变化，可以参数化
        const sortedByFreq = Object.entries(frequencies)
          .sort(([,a], [,b]) => b - a)
        
        dominantStyles[prop] = sortedByFreq[0][0] // 最常见的作为默认值
        variableStyles[prop] = {
          default: sortedByFreq[0][0],
          variations: Array.from(variations),
          frequencies: frequencies
        }
      }
      // 变化太多的属性暂时不处理
    })

    return {
      type: type,
      elementCount: elements.length,
      dominantStyles: dominantStyles,
      variableStyles: variableStyles,
      examples: elements.slice(0, 3) // 保留几个例子
    }
  }

  // 3. 提取可参数化的属性
  extractParameterizable(patterns) {
    const parameters = new Map()
    
    for (const [type, pattern] of patterns) {
      const typeParams = {}
      
      // 从可变样式中提取参数
      for (const [prop, variation] of Object.entries(pattern.variableStyles || {})) {
        const paramName = `${type}-${prop.replace(/([A-Z])/g, '-$1').toLowerCase()}`
        
        typeParams[paramName] = {
          property: prop,
          defaultValue: variation.default,
          possibleValues: variation.variations,
          description: this.generateParameterDescription(type, prop, variation)
        }
      }
      
      // 添加一些通用的可参数化属性
      typeParams[`${type}-primary-color`] = {
        property: 'color',
        defaultValue: pattern.dominantStyles.color || '#333333',
        cssVariable: `--${type}-color`,
        description: `${type}的主要文字颜色`
      }
      
      if (type.startsWith('heading')) {
        typeParams[`${type}-accent-color`] = {
          property: 'backgroundColor',
          defaultValue: 'transparent',
          cssVariable: `--${type}-bg-color`,
          description: `${type}的背景/强调色`
        }
      }
      
      parameters.set(type, typeParams)
    }
    
    return parameters
  }

  // 生成参数描述
  generateParameterDescription(type, property, variation) {
    const propDescriptions = {
      fontFamily: '字体系列',
      fontSize: '字体大小',
      fontWeight: '字体粗细',
      color: '文字颜色',
      marginTop: '上边距',
      marginBottom: '下边距',
      textAlign: '文本对齐',
      lineHeight: '行高'
    }
    
    return `${type}的${propDescriptions[property] || property}（默认: ${variation.default}）`
  }

  // 4. 生成CSS模板
  generateTemplate(patterns, parameters) {
    let css = this.generateCSSVariables(parameters)
    css += this.generateBaseStyles()
    css += this.generatePatternStyles(patterns, parameters)
    
    return {
      css: css,
      structure: this.generateTemplateStructure(patterns),
      usage: this.generateUsageGuide(parameters)
    }
  }

  // 生成CSS变量定义
  generateCSSVariables(parameters) {
    let variables = ':root {\n'
    
    for (const [type, typeParams] of parameters) {
      for (const [paramName, paramConfig] of Object.entries(typeParams)) {
        const cssVarName = paramConfig.cssVariable || `--${paramName}`
        variables += `  ${cssVarName}: ${paramConfig.defaultValue};\n`
      }
      variables += '\n'
    }
    
    variables += '}\n\n'
    return variables
  }

  // 生成基础样式
  generateBaseStyles() {
    return `
/* 文档基础样式 */
.word-template-container {
  max-width: 210mm; /* A4宽度 */
  margin: 0 auto;
  padding: 25mm 20mm; /* A4边距 */
  background: white;
  font-family: var(--primary-font, 'Times New Roman', serif);
  font-size: var(--base-font-size, 12pt);
  line-height: var(--base-line-height, 1.5);
  color: var(--text-color, #333333);
}

/* 重置样式，确保一致性 */
.word-template-container * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

`
  }

  // 根据模式生成样式规则
  generatePatternStyles(patterns, parameters) {
    let css = ''
    
    for (const [type, pattern] of patterns) {
      css += `/* ${type.toUpperCase()} 样式 */\n`
      css += this.generateTypeStyles(type, pattern, parameters.get(type) || {})
      css += '\n'
    }
    
    return css
  }

  // 为特定类型生成CSS规则
  generateTypeStyles(type, pattern, typeParams) {
    const selector = this.generateSelector(type)
    let css = `${selector} {\n`
    
    // 添加主导样式
    for (const [prop, value] of Object.entries(pattern.dominantStyles)) {
      const cssProperty = this.camelToKebabCase(prop)
      
      // 检查是否有对应的参数变量
      const paramKey = Object.keys(typeParams).find(key => 
        typeParams[key].property === prop
      )
      
      if (paramKey && typeParams[paramKey].cssVariable) {
        css += `  ${cssProperty}: var(${typeParams[paramKey].cssVariable}, ${value});\n`
      } else {
        css += `  ${cssProperty}: ${value};\n`
      }
    }
    
    // 添加类型特定的样式规则
    css += this.addTypeSpecificRules(type, pattern)
    
    css += '}\n'
    
    // 添加变体样式（如果有）
    css += this.generateVariantStyles(type, pattern, typeParams)
    
    return css
  }

  // 生成CSS选择器
  generateSelector(type) {
    const selectorMap = {
      'heading-1': '.word-template-container h1, .template-h1',
      'heading-2': '.word-template-container h2, .template-h2',
      'heading-3': '.word-template-container h3, .template-h3',
      'heading-4': '.word-template-container h4, .template-h4',
      'heading-5': '.word-template-container h5, .template-h5',
      'heading-6': '.word-template-container h6, .template-h6',
      'paragraph': '.word-template-container p, .template-p',
      'table-table': '.word-template-container table, .template-table',
      'table-th': '.word-template-container th, .template-th',
      'table-td': '.word-template-container td, .template-td',
      'blockquote': '.word-template-container blockquote, .template-blockquote',
      'list-ul': '.word-template-container ul, .template-ul',
      'list-ol': '.word-template-container ol, .template-ol',
      'list-li': '.word-template-container li, .template-li'
    }
    
    return selectorMap[type] || `.template-${type}`
  }

  // 添加类型特定的规则
  addTypeSpecificRules(type, pattern) {
    let rules = ''
    
    if (type.startsWith('heading')) {
      rules += `  font-weight: var(--${type}-font-weight, bold);\n`
      rules += `  margin-top: var(--${type}-margin-top, 1.2em);\n`
      rules += `  margin-bottom: var(--${type}-margin-bottom, 0.6em);\n`
      
      // 为标题添加装饰效果的钩子
      if (type === 'heading-1') {
        rules += `  position: relative;\n`
        rules += `  border-bottom: var(--h1-border-bottom, none);\n`
      }
    } else if (type === 'paragraph') {
      rules += `  margin-bottom: var(--paragraph-margin-bottom, 1em);\n`
      rules += `  text-indent: var(--paragraph-indent, 0);\n`
    } else if (type.startsWith('table')) {
      if (type === 'table-table') {
        rules += `  border-collapse: collapse;\n`
        rules += `  width: 100%;\n`
        rules += `  margin-bottom: var(--table-margin-bottom, 1em);\n`
      } else if (type === 'table-th' || type === 'table-td') {
        rules += `  border: var(--table-border, 1px solid #ccc);\n`
        rules += `  padding: var(--table-cell-padding, 8px);\n`
      }
    }
    
    return rules
  }

  // 生成变体样式
  generateVariantStyles(type, pattern, typeParams) {
    let css = ''
    
    // 为有多种变化的样式属性生成辅助类
    for (const [prop, variation] of Object.entries(pattern.variableStyles || {})) {
      if (variation.variations.length > 1) {
        variation.variations.forEach((value, index) => {
          const variantClass = `.${type}-${prop}-variant-${index + 1}`
          css += `${variantClass} {\n`
          css += `  ${this.camelToKebabCase(prop)}: ${value} !important;\n`
          css += `}\n`
        })
      }
    }
    
    return css
  }

  // 生成模板结构说明
  generateTemplateStructure(patterns) {
    const structure = {
      description: '此模板基于文档分析自动生成',
      elements: {},
      usage: '使用 .word-template-container 包装您的内容'
    }
    
    for (const [type, pattern] of patterns) {
      structure.elements[type] = {
        selector: this.generateSelector(type).split(',')[0].trim(),
        elementCount: pattern.elementCount,
        hasVariations: Object.keys(pattern.variableStyles || {}).length > 0,
        description: this.getTypeDescription(type)
      }
    }
    
    return structure
  }

  // 生成使用指南
  generateUsageGuide(parameters) {
    let guide = '# CSS模板使用指南\n\n'
    guide += '## 参数说明\n\n'
    
    for (const [type, typeParams] of parameters) {
      guide += `### ${type.toUpperCase()}\n`
      for (const [paramName, paramConfig] of Object.entries(typeParams)) {
        guide += `- **${paramName}**: ${paramConfig.description}\n`
        guide += `  - 默认值: \`${paramConfig.defaultValue}\`\n`
        if (paramConfig.possibleValues) {
          guide += `  - 可选值: ${paramConfig.possibleValues.join(', ')}\n`
        }
      }
      guide += '\n'
    }
    
    guide += '## 使用方法\n\n'
    guide += '```html\n'
    guide += '<div class="word-template-container">\n'
    guide += '  <h1>您的标题</h1>\n'
    guide += '  <p>您的段落内容</p>\n'
    guide += '  <!-- 更多内容 -->\n'
    guide += '</div>\n'
    guide += '```\n\n'
    
    guide += '## 自定义参数\n\n'
    guide += '您可以通过修改CSS变量来自定义样式：\n\n'
    guide += '```css\n'
    guide += ':root {\n'
    
    for (const [type, typeParams] of parameters) {
      for (const [paramName, paramConfig] of Object.entries(typeParams)) {
        if (paramConfig.cssVariable) {
          guide += `  ${paramConfig.cssVariable}: your-custom-value;\n`
        }
      }
    }
    
    guide += '}\n'
    guide += '```\n'
    
    return guide
  }

  // 5. 创建模板应用器
  createTemplateApplicator(template) {
    return {
      // 应用模板到新内容
      applyToContent: (content, customParameters = {}) => {
        return this.applyTemplateToContent(template, content, customParameters)
      },
      
      // 生成带有自定义参数的CSS
      generateCustomCSS: (customParameters = {}) => {
        return this.generateCustomizedCSS(template, customParameters)
      },
      
      // 验证内容结构
      validateContent: (content) => {
        return this.validateContentStructure(content, template.structure)
      },
      
      // 获取推荐的HTML结构
      getRecommendedStructure: () => {
        return this.generateRecommendedHTML(template.structure)
      }
    }
  }

  // 应用模板到新内容
  applyTemplateToContent(template, content, customParameters) {
    // 生成自定义CSS
    const customCSS = this.generateCustomizedCSS(template, customParameters)
    
    // 包装内容
    const wrappedContent = `
      <div class="word-template-container">
        ${content}
      </div>
    `
    
    return {
      html: wrappedContent,
      css: customCSS,
      fullDocument: this.generateFullDocument(wrappedContent, customCSS)
    }
  }

  // 生成自定义CSS
  generateCustomizedCSS(template, customParameters) {
    let css = template.css
    
    // 替换自定义参数
    for (const [paramName, value] of Object.entries(customParameters)) {
      const variable = `--${paramName}`
      const regex = new RegExp(`(${variable}\\s*:\\s*)[^;]+`, 'g')
      css = css.replace(regex, `$1${value}`)
    }
    
    return css
  }

  // 生成完整的HTML文档
  generateFullDocument(htmlContent, css) {
    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Document</title>
    <style>
${css}
    </style>
</head>
<body>
${htmlContent}
</body>
</html>
    `
  }

  // 工具方法
  camelToKebabCase(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
  }

  getTypeDescription(type) {
    const descriptions = {
      'heading-1': '一级标题样式',
      'heading-2': '二级标题样式', 
      'heading-3': '三级标题样式',
      'heading-4': '四级标题样式',
      'heading-5': '五级标题样式',
      'heading-6': '六级标题样式',
      'paragraph': '段落文本样式',
      'table-table': '表格容器样式',
      'table-th': '表格标题单元格样式',
      'table-td': '表格数据单元格样式',
      'blockquote': '引用块样式',
      'list-ul': '无序列表样式',
      'list-ol': '有序列表样式',
      'list-li': '列表项样式'
    }
    return descriptions[type] || `${type}样式`
  }

  getElementHierarchy(element) {
    const path = []
    let current = element
    while (current && current.tagName) {
      path.unshift(current.tagName.toLowerCase())
      current = current.parentElement
    }
    return path.join(' > ')
  }

  getElementPosition(element) {
    const rect = element.getBoundingClientRect()
    return {
      top: rect.top,
      left: rect.left,
      width: rect.width,
      height: rect.height
    }
  }
}

// 使用示例
class TemplateExtractionDemo {
  async demonstrateExtraction(htmlContent) {
    const extractor = new CSSTemplateExtractor()
    
    // 提取模板
    const templateResult = await extractor.extractTemplate(htmlContent)
    
    console.log('提取的CSS模板:', templateResult.template.css)
    console.log('可配置参数:', templateResult.parameters)
    
    // 应用模板到新内容
    const newContent = `
      <h1>新文档标题</h1>
      <p>这是新的段落内容。</p>
      <h2>子标题</h2>
      <p>更多内容段落。</p>
    `
    
    const applied = templateResult.applicator.applyToContent(newContent, {
      'heading-1-color': '#ff6b35',
      'paragraph-font-size': '14pt'
    })
    
    console.log('应用后的HTML:', applied.html)
    console.log('自定义CSS:', applied.css)
    
    return {
      template: templateResult,
      applied: applied
    }
  }
}

export { CSSTemplateExtractor, TemplateExtractionDemo }
```

## 总结
语义分析 + 模式识别 + 参数化
核心要点：
- 按语义类型分组分析（标题、段落、表格等）
- 识别重复的样式模式
- 提取可参数化的属性（颜色、字体、间距等）
- 生成CSS变量系统，支持主题切换

# 关键技术难点的解决策略
- 难点1： 字体精确还原
```
// 解决方案：提取并嵌入字体
- 从fontTable.xml提取字体定义
- 使用@font-face嵌入自定义字体
- 建立字体回退机制
```
- 难点2：间距和布局精确
```
// 解决方案：使用Word原生单位系统
- 保持twips→points转换精度
- 使用绝对定位处理复杂布局
- CSS Grid/Flexbox处理表格和列表
```
- 难点3：样式模板的通用性
```
// 解决方案：多层次参数系统
- 基础参数：颜色、字体、间距
- 语义参数：标题级别、段落类型
- 装饰参数：边框、背景、特效
```