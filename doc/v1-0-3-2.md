要“100%还原 Word”，你必须把 Word 的**完整渲染状态**拆成 12 类可提取数据；  
缺一类，像素就对不齐。下面给出：

1. **提取清单**（按重要性排序）  
2. **XML 文件来源**（Word 内部分布）  
3. **落地字段**（你最终拿到的 JS 对象 key）

→ 照单抓药，AI 代码就不会漏。

---

### ① 必须提取的 12 类内容

| 类 | 说明 | 不提取的后果 |
|---|---|---|
| 1. 页面几何 | 宽、高、四边距、装订线 | PDF 分页位置错位 |
| 2. 背景图 | 整页衬底图（页眉 or w:background） | 底层缺失，整体偏移 |
| 3. 浮动图片 | 绝对坐标 + z-index（behindDoc） | 图压文字 or 位置错 |
| 4. 段落属性 | 缩进、行距、段前段后、对齐 | 行高、首行空白不对 |
| 5. 字符属性 | 字号、粗斜、颜色、字体名 | 字宽变化 → 换行位置错 |
| 6. 表格属性 | 边框粗细、颜色、合并单元格 | 表框 ≠ PDF |
| 7. 表格行/列 | 宽、高、奇偶行填充色 | 列宽误差 |
| 8. 列表符号 | 编号样式、缩进级别 | 多级列表崩 |
| 9. 样式名 | 内置 + 用户自定义样式 ID | class 名对不上 |
|10. 主题颜色 |  Accent1/2… 映射到 RGB | 金色变灰色 |
|11. 语言/方向 | ar、he、rtl | 阿拉伯文边框左右反 |
|12. 缺省属性 | 无样式名时的 fallback 值 | 漏掉“看起来正常”的细调 |

---

### ② XML 来源地图（Word 内部）

| 数据 | 所在文件 | 关键节点 |
|---|---|---|
| 页面几何 | `word/document.xml` | `w:pgSz`, `w:pgMar` |
| 背景图 | `word/document.xml` or `header1.xml` | `w:background`, `pic:pic` |
| 浮动图片 | `word/document.xml` | `wp:anchor` + `a:blip` |
| 段落属性 | `word/document.xml` | `w:pPr` 内 `w:ind`, `w:spacing`… |
| 字符属性 | `word/document.xml` | `w:rPr` 内 `w:sz`, `w:color`… |
| 表格属性 | `word/document.xml` | `w:tblPr` + `w:tcPr` |
| 列表符号 | `word/numbering.xml` | `w:abstractNum` |
| 样式名 | `word/styles.xml` | `w:style` |
| 主题颜色 | `word/theme1.xml` | `a:accent1…a:accent6` |
| 语言/方向 | `word/document.xml` | `w:lang`, `w:bidi` |
| 缺省属性 | `word/document.xml` | `w:pPrDefault`, `w:rPrDefault` |

---

### ③ 落地字段（你最终拿到的 JS 对象）

```ts
interface WordState {
  page: { width: number; height: number; margin: [number, number, number, number] };
  backgroundImage?: { src: string; type: 'A' | 'B' };
  floatingImages: { src: string; left: string; top: string; zIndex: number }[];
  paragraphs: {
    styleId?: string;
    indent: { firstLine?: number; hanging?: number; left?: number };
    spacing: { before?: number; after?: number; line?: number; lineRule?: string };
    alignment: 'left' | 'center' | 'right';
    runs: {
      text: string;
      bold?: boolean; italic?: boolean; color?: string; font?: string; sz?: number;
    }[];
  }[];
  tables: {
    styleId?: string;
    borders: { top: Border, left: Border, bottom: Border, right: Border, insideH: Border, insideV: Border };
    rows: {
      height?: number;
      cells: { width?: number; colSpan?: number; background?: string; content: Paragraph[] }[];
    }[];
  }[];
  lists: {
    abstractNumId: number;
    levels: { numFmt: 'bullet' | 'decimal'; lvlText: string; indent: number }[];
  }[];
  themeColors: { accent1: string; accent2: string; accent3: string; accent4: string; accent5: string; accent6: string };
  lang: string;
  rtl: boolean;
}
```

---

### ④ 提取顺序（流水线）

1. **解压** → `JSZip.loadAsync(buffer)`  
2. **主题色** → 先读 `theme1.xml` 拿到 Accent1-6 RGB  
3. **背景图** → `detectBackgroundRel(zip)`  
4. **样式表** → `parseStylesXml(zip)` → 产出 `styleId → CSS 属性` 映射  
5. **编号表** → `parseNumberingXml(zip)` → 产出 `abstractNumId → 符号/编号`  
6. **文档主体** → `parseDocumentXml(zip, 映射表)` → 产出 `paragraphs[], tables[], floatingImages[]`  
7. **生成 HTML** → 把以上对象喂给 `renderToHtml(state)` → 输出带 class 的 HTML + CSS 字符串

---

### ⑤ 一句话总结（给 AI 的提示词可直接用）

> 「把 .docx 解压后，依次提取 theme1.xml 主题色、styles.xml 样式名、numbering.xml 列表、document.xml 里全部段落+表格+图片+页面几何+背景图，转成 JS 对象，再映射到与 t.html 变量对齐的 CSS 类，最终返回 {html, css, backgroundImage, floatingImages}，即可 100% 还原 Word。」

按这张「12 类清单」抓数据，**像素就不会丢**。